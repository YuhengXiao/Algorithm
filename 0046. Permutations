class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> temp  = new ArrayList<Integer>();
        if (nums.length == 0 ){
            return res;
        }
        boolean [] visited = new boolean[nums.length];
        backtracking(res, temp, visited, nums);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> temp, boolean[] visited, int[] nums){
        if (temp.size() == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++){
            if (visited[i] == true){
                continue;
            }
            temp.add(nums[i]);
            visited[i] = true;
            backtracking(res, temp, visited, nums);
            temp.remove(temp.size() - 1);
            visited[i] = false;
        }
    }

}

/*
Note:

(1.	Using “For loop + Recursion + visiting information” when we want to get all the Permutations.
(2.	Using “Recursion” when we want to get all the combinations.
(3.	Using ” Backtracking” when we want to get particular combinations of all.

1.	“Iterating a list”: The following are equivalent ways to iterate over a list:

        for (String i : myList) {

             System.out.println(i);
        }

// equivalent to:


        for (int i = 0; i < myList.size(); i++) {
            System.out.println(myList.get(i));
        }
        
 // equivalent to:

        while (it.hasNext()) {
 
            // Print all elements of List
            System.out.println(it.next());
        }

2.	“Collections.swap(List list, int i, int j)”: The swap() method of java.util.Collections class is used to swap the elements at the specified positions in the specified list. If the specified positions are equal, invoking this method leaves the list unchanged.
     Collections.swap(combination, index, i);
     
3.	“Permutation”: Using “For loop + Recursion”:
(1)	“For loop” iterates all the valid possibilities of the first index we can select of the current “node”;
(2)	“Recursion” is telling the “For loop of the next sub-node (next row)” which indexes are valid.
(3)	“Visiting information” are required because the same index may be iterated repeatedly in another “for loop” not like “combination” will just occur in one “for loop”.
        for (int i = 0; i < nums.length; i++){
            if (visited[i] == true){
                continue;
            }
            temp.add(nums[i]);
            visited[i] = true;
            backtracking(res, temp, visited, nums);
            temp.remove(temp.size() - 1);
            visited[i] = false;
        }


*/
