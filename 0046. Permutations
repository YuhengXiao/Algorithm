class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> temp  = new ArrayList<Integer>();
        if (nums.length == 0 ){
            return res;
        }
        boolean [] visited = new boolean[nums.length];
        backtracking(res, temp, visited, nums);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> temp, boolean[] visited, int[] nums){
        if (temp.size() == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++){
            if (visited[i] == true){
                continue;
            }
            temp.add(nums[i]);
            visited[i] = true;
            backtracking(res, temp, visited, nums);
            temp.remove(temp.size() - 1);
            visited[i] = false;
        }
    }

}

/*
Note:
(1.	Using backtracking: “For loop + Recursion + visiting information(boolean[] visited)” when we want to get all the Permutations.
(2.	Q78 is about the Combination.

1.	“Iterating a list”: The following are equivalent ways to iterate over a list:

        for (String i : myList) {

             System.out.println(i);
        }

   // equivalent to:


        for (int i = 0; i < myList.size(); i++) {
            System.out.println(myList.get(i));
        }
        
   // equivalent to:

        while (it.hasNext()) {
 
            // Print all elements of List
            System.out.println(it.next());
        }

2.	“Collections.swap(List list, int i, int j)”: The swap() method of java.util.Collections class is used to swap the elements at the specified positions in the specified list. If the specified positions are equal, invoking this method leaves the list unchanged.
    Collections.swap(combination, index, i);

3.	“Permutation”: Using “For loop + Recursion”:
  (1)	“For loop” iterates all the valid indexes we can select of the current “node” (we will just select one possible index and do the “recursion” at a time);
            for (int i = 0; i < nums.length; i++){
                if (visited[i] == true){
                   continue;
            }
  (2)	“Recursion” is telling the “For loop of the next sub-node (next row)” which indexes are valid.
                   backtracking(res, temp, visited, nums);
        We need to remove the element we just added into the List to make room for the next possible element.
                   temp.remove(temp.size() - 1);

   (3)	“Visiting information” are required because the same index may be iterated repeatedly in another “for loop” not like “combination” will just occur in one “for loop”.
         We need to set the visited array after adding or removing, that’s why “recursion” can tell the “For loop of the next sub-node (next row)” which indexes are valid.
        
        for (int i = 0; i < nums.length; i++){
            if (visited[i] == true){
                continue;
            }
            temp.add(nums[i]);
            visited[i] = true;
            backtracking(res, temp, visited, nums);
            temp.remove(temp.size() - 1);
            visited[i] = false;
        }


*/
