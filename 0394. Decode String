class Solution {
    public String decodeString(String s) {
        Stack<Character> stack = new Stack<Character>();
        for(char c : s.toCharArray()){
            if(c != ']'){
                stack.push(c);
            } else{               
                StringBuilder word = new StringBuilder();
                while(!stack.isEmpty() && Character.isLetter(stack.peek())){
                    word.insert(0, stack.pop());
                }
                stack.pop();

                StringBuilder num = new StringBuilder();
                while(!stack.isEmpty() && Character.isDigit(stack.peek())){
                    num.insert(0, stack.pop());
                }
                int count = Integer.valueOf(num.toString());
                while(count > 0){
                    for(char t : String.valueOf(word).toCharArray()){
                        stack.push(t);
                    }
                    count--;
                }

            }
        }
        String ans = "";
        while(!stack.isEmpty()){
            ans = String.valueOf(stack.pop()) + ans;
        }
        return ans;
    }
}

/*
Notes:

(Using “Stack” and “StringBuilder”)

1.	“Stack” interface:
Stack<Character> stack = new Stack<Character>();
2.	“StringBuilder”: are used when there is a necessity to make a lot of modifications to Strings of characters.
*StringBuilder is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
*StringBuffer is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously. 

      
     -1: create a StringBuilder object:
        // using StringBuilder() constructor
        StringBuilder str
            = new StringBuilder();

     -2: output a StringBuilder object:
       // using “toString()” convert StringBuilder into String
	    System.out.println("String1 = " + str1.toString());

1: length() and capacity() Methods:
        // Getting the length of the string
        int p = s.length();
 
        // Getting the capacity of the string
        int q = s.capacity();

2: append() : It is used to add text at the end of the existing text. 
        // Usage of append() method
        s.append("Geeks");
  
        s.append(1);
3: insert(): It is used to insert text at the specified index position. 
     StringBuffer insert(int index, String str)
     StringBuffer insert(int index, char ch)
4: reverse( ): It can reverse the characters: 
        // Invoking reverse() method
        s.reverse();
5: delete( ) and deleteCharAt():
   StringBuffer delete(int startIndex, int endIndex)
   StringBuffer deleteCharAt(int loc)
6: replace():The substring being replaced is specified by the indexes start Index and endIndex. 
StringBuffer replace(int startIndex, int endIndex, String str)
--------------------------------approach 1-----------------------------------
                StringBuilder num = new StringBuilder();
                while(!stack.isEmpty() && Character.isDigit(stack.peek())){
                    num.insert(0, stack.pop());
                }
--------------------------------approach 2-----------------------------------
        String ans = "";
        while(!stack.isEmpty()){
            ans = String.valueOf(stack.pop()) + ans;
        }

3.	“Character.isLetter(char ch)”: This method returns true if the passed character is really a character.
      System.out.println(Character.isLetter('c'));
      System.out.println(Character.isLetter('5'));
   Output
    true
    false
4.	“isDigit(char ch)”: This method returns true, if the passed character is really a digit.
      System.out.println(Character.isDigit('c'));
      System.out.println(Character.isDigit('5'));
Output
   false
   true


*/
