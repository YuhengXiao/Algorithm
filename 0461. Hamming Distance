class Solution {
    public int hammingDistance(int x, int y) {
        int difference = x ^ y;
        int ans = 0;
        while(difference != 0){
            ans = ans + (difference & 1);
            difference = difference >> 1;
        }
        return ans;
    }
}

/*
Notes:

(Using “Bitwise operator”. To point out: “Bitwise operators” ’s precedence is lower than “logical operators”(+, -, *, /), so we don’t forget to use round bracket in some situations)

1.	Bitwise AND (&): It is a binary operator denoted by the symbol &. It returns 1 if and only if both bits are 1, else returns 0.
 
int x = 9, y = 8;   
// bitwise and   
// 1001 & 1000 = 1000 = 8  
System.out.println("x & y = " + (x & y));   
Output
x & y = 8

2.	Bitwise exclusive OR (^): It is a binary operator denoted by the symbol ^ (pronounced as caret). It returns 0 if both bits are the same, else returns 1.
 
int x = 9, y = 8;   
// bitwise XOR   
// 1001 ^ 1000 = 0001 = 1  
System.out.println("x ^ y = " + (x ^ y));   
Output
x ^ y = 1

3.	Bitwise inclusive OR (|): It is a binary operator denoted by the symbol | (pronounced as a pipe). It returns 1 if either of the bit is 1, else returns 0.
 
int x = 9, y = 8;   
// bitwise inclusive OR  
// 1001 | 1000 = 1001 = 9  
System.out.println("x | y = " + (x | y));   
Output
x | y = 9

4.	Bitwise Complement (~): It is a unary operator denoted by the symbol ~ (pronounced as the tilde). It returns the inverse or complement of the bit. It makes every 0 a 1 and every 1 a 0.

 
int x = 2;   
// bitwise compliment  
// ~0010= 1101 = -3  
System.out.println("~x = " + (~x));   
Output
~x = -3

5.	Signed Right Shift Operator (>>): The signed right shift operator shifts a bit pattern of a number towards the right with a specified number of positions and fills 0. The operator is denoted by the symbol >>. It also preserves the leftmost bit (sign bit). If 0 is presented at the leftmost bit, it means the number is positive. If 1 is presented at the leftmost bit, it means the number is negative. 
In general, if we write a>>n, it means to shift the bits of a number toward the right with a specified position (n). In the terms of mathematics, we can represent the signed right shift operator as follows:
If x = 256
256 >> 4
256/24 = 16

If x = -256
-256 >> 4
-256/24 = -16
int x = 50;   
System.out.println("x>>2 = " + (x >>2));   
Output
 x>>2 = 12

6.	Signed Left Shift Operator (<<): The signed left shift operator (<<) shifts a bit pattern to the left. It is represented by the symbol <<. It also preserves the leftmost bit (sign bit). It does not preserve the sign bit. In general, if we write a<<n, it means to shift the bits of a number toward the left with specified position (n). In the terms of mathematics, we can represent the signed right shift operator as follows:

Example 1: What will be the result after shifting a<<3. The value of a is 20.
Representation of 20 in binary is = 00010100
After performing the left shift operator, we get:
a << 3 = 10100000 (last three bits are the filled bits)
a << 3 = 160
Let's check the result by using the formula.
20 << 3
20*23 = 20*8 = 160

Example 2: What will be the result after shifting a<<2. The value of a is -10.
Representation of -10 in binary is = 11110110
a<<2 = 11011000 = -40
Let's check the result by using the formula.
-10 << 3
-10*22 = -10*4 = -40
Let's create a Java program and implement the signed left shift operator.
int x = 12;   
System.out.println("x<<1 = " + (x << 1));   
Output
 x<<1 = 24

7.	Unsigned Right Shift Operator (>>>): It shifts a zero at the leftmost position and fills 0. It is denoted by the symbol >>>. Note that the leftmost position after >> depends on the sign bit. It does not preserve the sign bit.

>> is arithmetic shift right, >>> is logical shift right.
In an arithmetic shift, the sign bit is extended to preserve the signedness of the number.

For example: 
-2 represented in 8 bits would be 11111110 (because the most significant bit has negative weight). 
Logical right shift(>>), shifting it right one bit using arithmetic shift would give you 11111111, or -1. 
Logical right shift(>>>), does not care that the value could possibly represent a signed number; it simply moves everything to the right and fills in from the left with 0s. Shifting our -2 right one bit using logical shift would give 01111111.
int x = 20;   
System.out.println("x>>>2 = " + (x >>>2));   
Output
 x>>>2 = 5


*/
