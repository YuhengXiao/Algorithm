class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int ans = 0;
        int sum = 0;
        map.put(0, 1);
        for (int i = 0; i < nums.length; i++){
            sum = sum + nums[i];
            if (map.containsKey(sum - k)){
                ans = ans + map.get(sum - k);
            }
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return ans;
    }
}

/*
Notes:

(Using “Prefix Sum” + “HashMap” when “Sliding Windows” doesn’t work(contains negatives, which means we cannot make sure subtract the head elements from sum will decrease the sum).)

1.	“Prefix Sum”: 
  (1)	if the cumulative sum up to two indices, say i and j is at a difference of k. 
  (2)	if sum[i]−sum[j]=k, the sum of elements lying between indices i and j is kk.
  (3)	DON’T omit the sum[0]: means the pre value of the first element is zero.
 
2.	Using “HashMap” to optimize the “Cumulative Sum”: by counting the “pre values” and it’s “times”.
  (1)	Every time we encounter a new sum, we make a new entry in the HashMap corresponding to that sum. If the same sum occurs again, we increment the count corresponding to that sum in the HashMap.
  (2)	For every new pre value encountered, we check the number of times the sum-sum−k has occurred already in the HashMap. We increment the count by the same amount if it has occurred.
  (3)	Checking the HashMap before Adding the current pre value into the HashMap, because “Adding current pre value into HashMap” is for next “pre value’s check”.

*/
