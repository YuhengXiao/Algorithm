class Solution {
    public int divide(int dividend, int divisor) {
        if (dividend == Integer.MIN_VALUE){
            if (divisor == 1){
                return Integer.MIN_VALUE;
            }
            if (divisor == -1){
                return Integer.MAX_VALUE;
            }
        }
        if (divisor == Integer.MIN_VALUE){
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }
        boolean positive = true;
        if (dividend > 0){
            dividend = -dividend;
            positive = !positive;
        }
        if (divisor > 0){
            divisor = - divisor;
            positive = !positive;
        }
        List<Integer> lst = new ArrayList<Integer>();
        int temp = divisor;
        lst.add(temp);
        while (temp >= dividend - temp){
            temp = temp + temp;
            lst.add(temp);
        }
        int ans = 0;
        for (int i = lst.size() - 1; i >= 0; i--){
            if (dividend - lst.get(i) <= 0){
                ans = ans + (1 << i);
                dividend = dividend - lst.get(i);
            }
            if (dividend == 0 || dividend > divisor){
                return positive ? ans : -ans; 
            }
        }
        return positive ? ans : -ans;
    }
}


/*
Notes:

(Using “Exponentiation by squaring”.)

1.	“Integer.MAX_VALUE”: representing the maximum value of Integer type (2^31 - 1).

2.	“Integer.MIN_VALUE”: representing the minimum value of Integer type (2^31).

3.	“Exponentiation by squaring”: Using “Divide & Conquer” in Exponentiation.

  (1)	Using “recursion” to figure out “X^(n/2)”, chop off the decimal portion.
  (2)	If n is even, the current result equals to its last result’s square.
  (3)	If n is odd, the current result equals to its last result’s square multiply by one X.

  For example, if we want to calculate “X^64”, we can process in this order:
    x→x2→x4→x8→x16→x32→x64
  For example, if we want to calculate “X^77”, we can process in this order:
    x→x2→x4→x9→x19→x38→x77

*/
