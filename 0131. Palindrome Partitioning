class Solution {
    int[][] cashe; // 0: NaN; 1: yes; 2:no
    List<String> temp = new ArrayList<String>();
    List<List<String>> ans = new ArrayList<List<String>>();

    public List<List<String>> partition(String s) {
        cashe = new int[s.length()][s.length()];
        dfs(s, 0);
        return ans;
    }

    public void dfs(String s, int start){
        if (start == s.length()){
            ans.add(new ArrayList<String>(temp));
            return;
        }
        for (int end = start; end < s.length(); end++){
            if (check(s, start, end) == 1){
                temp.add(s.substring(start, end + 1));
                dfs(s, end + 1);
                temp.remove(temp.size() - 1);
            }
        }
    }

    public int check(String s, int a, int b){
        if (cashe[a][b] != 0){
            return cashe[a][b];
        }
        if (a >= b){
            cashe[a][b] = 1;
        } else if (s.charAt(a) == s.charAt(b)){
            cashe[a][b] = check(s, a + 1, b - 1);
        } else{
            cashe[a][b] = 2;
        }
        return cashe[a][b];
    }
}

/*
Notes:

(Using “Backtracking” to find all possible palindromes in a string.)
*/
