class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        return dfs(coins, amount, dp);
    }
    public int dfs(int[] coins, int amount, int[]dp){
        if (amount < 0){
            return -1;
        }
        if (amount == 0){
            return 0;
        }
        if (dp[amount] != 0){
            return dp[amount];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < coins.length; i++){
            int temp = dfs(coins, amount - coins[i], dp) + 1;
            if (temp > 0 && temp < min){
                min = temp;
            }
        }
        dp[amount] = (min == Integer.MAX_VALUE) ? -1 : min;
        return dp[amount];
    }
}

/*
Notes:

(Using “Dynamic Programming (Cashing)” + “DFS”: to optimize “backtracking”
The “Cashing format”: discussed on Q494.)


1.	“Integer.MAX_VALUE”: represent the biggest value of Integer type.
2.	“Integer.MIN_VALUE”: represent the minimum value of Integer type.

https://www.youtube.com/watch?v=H9bfqozjoqs&t=2s
*/
