class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> Combinations = new ArrayList<String>();
        if (digits.length() == 0){
            return Combinations;
        }
        Map<Character, String> phone = new HashMap<Character, String>();
            phone.put('2', "abc");
            phone.put('3', "def");
            phone.put('4', "ghi");
            phone.put('5', "jkl");
            phone.put('6', "mno");
            phone.put('7', "pqrs");
            phone.put('8', "tuv");
            phone.put('9', "wxyz");
        StringBuffer temp = new StringBuffer();
        backtraking(Combinations, phone, digits, 0, temp);
        return Combinations;
    }

    public void backtraking(List<String> Combinations, Map<Character, String> phone, String digits, int index, StringBuffer temp){
        if (index == digits.length()){
            Combinations.add(temp.toString());
        }
        else{
            char num = digits.charAt(index);
            String letters = phone.get(num);
            for(int i =0; i < letters.length(); i++){
                temp.append(letters.charAt(i));
                backtraking(Combinations, phone, digits, index + 1, temp);
                temp.deleteCharAt(index);
            }
        }
    }
    
}

/*
Note:
(Backtracking: is a general algorithm for finding solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.)

    The difference between “recursion” and “backtracking”:
    recursion - no values abandoned(must have a “base case”);  
    backtracking - abandon some solution candidates(might have a “base case”);

1.	The StringBuffer class: are used when there is a necessity to make a lot of modifications to Strings of characters. (The difference between “StringBuffer” and “Creating a new List” to store String is : String stored in “StringBuffer” are concatenate, but in “Creating a new List” they are nested string.)
 -1: create a StringBuilder object:
        // using StringBuilder() constructor
        StringBuilder str
            = new StringBuilder();

-2: output a StringBuilder object:
       // using “toString()” convert StringBuilder into String
	       System.out.println("String1 = " + str1.toString());

0: create a StringBuilder object:
   public static void main(String args[]) {
      StringBuffer sBuffer = new StringBuffer();
      sBuffer.append(" String Buffer");
      System.out.println(sBuffer);  
   }

1: length() and capacity() Methods:
        // Getting the length of the string
        int p = s.length();
 
        // Getting the capacity of the string
        int q = s.capacity();

2: append() : It is used to add text at the end of the existing text. 
        // Usage of append() method
        s.append("Geeks");
  
        s.append(1);
3: insert(): It is used to insert text at the specified index position. 
     StringBuffer insert(int index, String str)
     StringBuffer insert(int index, char ch)
4: reverse( ): It can reverse the characters: 
        // Invoking reverse() method
        s.reverse();
5: delete( ) and deleteCharAt():
   StringBuffer delete(int startIndex, int endIndex)
   StringBuffer deleteCharAt(int loc)
6: replace():The substring being replaced is specified by the indexes start Index and endIndex. 
   StringBuffer replace(int startIndex, int endIndex, String str)

*/
