class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new LinkedList<Integer>();
        HashMap<Character, Integer> smap = new HashMap<Character, Integer>();
        HashMap<Character, Integer> pmap = new HashMap<Character, Integer>();
        if (s.length() < p.length()){
            return ans;
        }
        for (int i = 0; i < p.length(); i++){
            smap.put(s.charAt(i), smap.getOrDefault(s.charAt(i), 0) + 1);
            pmap.put(p.charAt(i), pmap.getOrDefault(p.charAt(i), 0) + 1);
        }
        for (int j = 0; j < s.length() - p.length(); j++){
            if (checksame(smap, pmap)){
                ans.add(j);
            }
            smap.put(s.charAt(j + p.length()), smap.getOrDefault(s.charAt(j + p.length()), 0) + 1);
            if (smap.get(s.charAt(j)) == 1){
                smap.remove(s.charAt(j));
            } else{
                smap.put(s.charAt(j), smap.get(s.charAt(j)) - 1);
            }
        }
        if (checksame(smap, pmap)){
            ans.add(s.length() - p.length());
        }
        return ans;
    }
    public boolean checksame(HashMap<Character, Integer> smap, HashMap<Character, Integer> pmap){
        for (HashMap.Entry<Character, Integer> entry : pmap.entrySet()){
            if (!smap.containsKey(entry.getKey())){
                return false;
            }
            if (smap.get(entry.getKey()).intValue() != entry.getValue().intValue()){
                return false;
            }
        }
        return true;
    }

}

/*
Notes:

(Using “Window Sliding Technique”: adding a new element at the end of subarray and remove the first element at the head of the subarray and check if the current subarray meet the requirement every time.)

1.	“.intValue()”: we better change “Integer” to “Int” when we want to compare values of two “Integers”(“Int” is a type, “Integer” is a class object).
    
            if (smap.get(entry.getKey()).intValue() != entry.getValue().intValue()){
  
    }

*/
