class Solution {
    public int minDistance(String word1, String word2) {
        int[][] ans = new int[word2.length() + 1][word1.length() + 1];
        if (word1.length() * word2.length() == 0){
            return word1.length() + word2.length();
        }
        for (int i = 0; i < word2.length() + 1; i++){
            ans[i][0] = i;
        }
        for (int j = 0; j < word1.length() + 1; j++){
            ans[0][j] = j;
        }
        for (int i = 1; i < word2.length() + 1; i++){
            for(int j = 1; j < word1.length() + 1; j++){
                if (word2.charAt(i - 1) == word1.charAt(j - 1)){
                    ans[i][j] = Math.min(ans[i - 1][j] + 1, Math.min(ans[i][j - 1] + 1, ans[i - 1][j - 1]));
                }
                else{
                    ans[i][j] = Math.min(ans[i - 1][j] + 1, Math.min(ans[i][j - 1] + 1, ans[i - 1][j - 1] + 1));
                }
            }
        }
        return ans[word2.length()][word1.length()];
    }
}

/*
Note:

(Using Dynamic Programming)

Value functions of Q72:
When word2.charAt(i - 1) == word1.charAt(j - 1): 
    D [ i ][ j ] = min ( D [ i ][ j – 1 ] + 1 , D [ i – 1 ][ j ] + 1 , D [ i – 1 ][ j – 1 ] )
When word2.charAt(i - 1) != word1.charAt(j - 1):
D [ i ][ j ] = min ( D [ i ][ j−1] + 1, D [ i − 1][ j ] + 1, D [ i – 1 ][ j – 1 ] +1 )

Explanation: The minimum number of operations required to “convert the current character of word1 to the current character of word2” equals to 1 add the minimum of operations required to 
“convert the previous character of word1 to the current character of word2”, 
“convert the current character of word1 to the previous character of word2”, 
“convert the previous current character of word1 to the previous character of word2”.

*”Boundary condition”: 
1. we set leftmost column from “0” to the “word1.length() + 1”
2. we set bottem row from “0” to the “word2. Length() +1”.
3. we set dp[0][0] = 0 : because strings could be null.
4. we start from dp[1][1] instead of dp[0][0]
5. we need to consider whether “current character of each words are equal” or not every time:
  If they are equal: we pass the value of min( D [ i ][ j – 1 ] + 1 , D [ i – 1 ][ j ] + 1 , D [ i – 1 ][ j – 1 ] ) to new dp[][].
  If they are not equal: we pass the value of D [ i ][ j ] = min ( D [ i ][ j−1] + 1, D [ i − 1][ j ] + 1, D [ i – 1 ][ j – 1 ] +1 ) to new dp[][].

*/
