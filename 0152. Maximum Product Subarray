class Solution {
    public int maxProduct(int[] nums) {
        int len = nums.length;
        int[] max = new int[len];
        int[] min = new int[len];
        max[0] = nums[0];
        min[0] = nums[0];
        for (int i = 1; i < nums.length; i++){
            max[i] = Math.max(max[i - 1] * nums[i], Math.max(min[i - 1] * nums[i], nums[i]));
            min[i] = Math.min(min[i - 1] * nums[i], Math.min(max[i - 1] * nums[i], nums[i]));
        }
        int ans = nums[0];
        for (int j = 1; j < nums.length; j ++){
            if (max[j] > ans){
                ans = max[j];
            }
        }
        return ans;
    }
}

/*
Notes:

(Using “Dynamic Programming”)

Value functions of Q152: 
Fmax(i) = max{ Fmax(i - 1) * i, Fmin(i - 1) * i, i }
Fmin(i) = min{ Fmax(i - 1) * i, Fmin(i - 1) * i, i }


Explanation: 
If the current number is positive, we can multiply it by the max to get the current maximum.
If the current number is negative, we can multiply it by the min to get the current maximum. (The max array is the target, and the min array is a helper.) 

*”Boundary condition”: 
1. We set the first element of max array.
2. We set the first element of min array.
3. We start from second element.

*/
