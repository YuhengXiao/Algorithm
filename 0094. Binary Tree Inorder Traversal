class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        inorder(root, ans);
        return ans;
    }

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }
}

/*
Notes:

(1. Using “Recursion” to traverse a binary tree.
2. the position of “adding node’s value” decide the way of traversal(pre-order, in-order, post-order))

1.	Pre-order:  
(1)	Visit the current node.
(2)	Recursively traverse the current node's left subtree.
(3)	Recursively traverse the current node's right subtree.

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        ans.add(root.val);
        inorder(root.left, ans);
        inorder(root.right, ans);             
    }

2.	Post-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Recursively traverse the current node's right subtree.
(3)	Visit the current node.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        inorder(root.right, ans);   
        ans.add(root.val);          
    }

3.	In-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Visit the current node.
(3)	Recursively traverse the current node's right subtree.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }


*/
