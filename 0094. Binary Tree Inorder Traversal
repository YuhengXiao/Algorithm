class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        inorder(root, ans);
        return ans;
    }

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }
}

/*
Notes:

(1. Using “Recursion” to traverse a binary tree.
2. the position of “adding node’s value” decide the way of traversal(“pre order”, “in order”, “post order”))


1.	Traverse a binary tree:
   class Solution {
     public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        inorder(root, ans);
        return ans;
     }

     public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);
        inorder(root.right, ans);             
     }
  }

(1)	Time complexity：O(n)
    N is the number of nodes, each node will be traversed only once.
(2)	Space complexity: O(n)
    The space complexity depends on the depth of recursion.

2.	Pre-order:  
(1)	Visit the current node.
(2)	Recursively traverse the current node's left subtree.
(3)	Recursively traverse the current node's right subtree.

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        ans.add(root.val);
        inorder(root.left, ans);
        inorder(root.right, ans);             
    }


3.	Post-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Recursively traverse the current node's right subtree.
(3)	Visit the current node.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        inorder(root.right, ans);   
        ans.add(root.val);          
    }

4.	In-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Visit the current node.
(3)	Recursively traverse the current node's right subtree.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }

         1
      /    \       
     2       3
   /   \      \  
  4     5      6
Postorder traversal = {4, 5, 2, 6, 3, 1}
Inorder traversal = {4, 2, 5, 1, 3, 6}
Preorder traversal = {1, 2, 4, 5, 3, 6}


*/
