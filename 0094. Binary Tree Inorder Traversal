class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        inorder(root, ans);
        return ans;
    }

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }
}

/*
Notes:

(1. Using “Recursion” to traverse a binary tree.
2. the position of “adding node’s value” decide the way of traversal(pre-order, in-order, post-order))

1.	Traverse a binary tree:
   class Solution {
     public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        inorder(root, ans);
        return ans;
     }

     public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);
        inorder(root.right, ans);             
     }
  }

(1)	Time complexity：O(n)
    N is the number of nodes, each node will be traversed only once.
(2)	Space complexity: O(n)
    The space complexity depends on the depth of recursion.

2.	Pre-order:  
(1)	Visit the current node.
(2)	Recursively traverse the current node's left subtree.
(3)	Recursively traverse the current node's right subtree.

    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        ans.add(root.val);
        inorder(root.left, ans);
        inorder(root.right, ans);             
    }


3.	Post-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Recursively traverse the current node's right subtree.
(3)	Visit the current node.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        inorder(root.right, ans);   
        ans.add(root.val);          
    }

4.	In-order:
(1)	Recursively traverse the current node's left subtree.
(2)	Visit the current node.
(3)	Recursively traverse the current node's right subtree.
    public void inorder(TreeNode root, List<Integer> ans){
        if (root == null){
            return;
        }      
        inorder(root.left, ans);
        ans.add(root.val);  
        inorder(root.right, ans);           
    }

*/
